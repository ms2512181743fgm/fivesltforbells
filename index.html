<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Let’s Match b/e/l/l/e!</title>

<meta property="og:title" content="Let’s Match b/e/l/l/e!">
<meta property="og:description" content="スロット風ゲームを遊んでみよう！">
<meta property="og:type" content="website">
<meta property="og:url" content="https://ms2512181743fgm.github.io/testgamesltmcn/">
<meta property="og:image" content="https://ms2512181743fgm.github.io/testgamesltmcn/ogp.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="robots" content="noindex, nofollow">

<style>
  body {
    font-family: sans-serif;
    text-align: center;
    background: #000;
    font-size: 24px;
    padding: env(safe-area-inset-top) 20px env(safe-area-inset-bottom);
    margin: 0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
  }

  h1 {
    margin: 10px 0 10px;
    font-size: 40px;
    color: magenta;
  }

  .reels {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 10px 0 20px;
  }

  .reel {
    width: 140px;
    height: 210px; /* 枠だけ1.5倍 */
    overflow: hidden;
    border: 4px solid #333;
    border-radius: 12px;

    background-image: url("slt265x1325.png");
    background-repeat: repeat-y;
    background-size: 140px 700px; /* PNGは元の縮尺 */
    background-position-y: 0;
  }

  .stop-btn {
    font-size: 40px;
    cursor: pointer;
    display: none;
    margin-top: 5px;
    color: magenta;
  }

  #excellent {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 120px;
    font-weight: bold;
    color: rgba(255,0,255,0.9);
    display: none;
    pointer-events: none;
  }

  #resultText {
    font-size: 40px;
    margin-top: 10px;
    min-height: 50px;
    color: magenta;
  }

  #startBtn {
    padding: 10px 25px;
    font-size: 26px;
    margin: 10px auto;
    color: magenta;
    border: 3px solid magenta;
    background: #fff;
    border-radius: 10px;
    cursor: pointer;
  }
</style>
</head>
<body>

<h1>Let’s Match b/e/l/l/e!</h1>

<div class="reels" id="reels"></div>

<div id="excellent">EXCELLENT!!</div>
<div id="resultText"></div>

<button id="startBtn">START</button>

<script>
const REELS = 5;

const oneHeight = 140;      // PNGの1コマ高さ
const totalHeight = 700;    // 140 × 5
const frameHeight = 210;    // 枠の高さ（1.5倍）
const centerOffset = (frameHeight - oneHeight) / 2; // 35px → 中央揃え補正

const baseMaxSpeed = 14.4;  // トップスピード1.2倍
let fixedMaxSpeed = baseMaxSpeed;
const accelDuration = 2000;

let reels = [];
let speeds = Array(REELS).fill(0);

/* belle が中央に来るように調整（140px単位） */
let positions = [
  560, // b
  420, // e
  280, // l
  140, // l
  0    // e
];

let spinning = Array(REELS).fill(false);
let stopped = Array(REELS).fill(false);

const reelsContainer = document.getElementById("reels");
const startBtn = document.getElementById("startBtn");
const excellent = document.getElementById("excellent");
const resultText = document.getElementById("resultText");

/* 揃いパターン辞書 */
const messages = {
  "belle": { text: "大当たり！", excellent: true },
  "beeee": { text: "べーーー", excellent: false },
  "leeee": { text: "りーーー", excellent: false },
  "bbbbb": { text: "bを揃えた、しかし何も起こらなかった...", excellent: false },
  "eeeee": { text: "eを揃えた、しかし何も起こらなかった...", excellent: false },
  "lllll": { text: "lを揃えた、しかし何も起こらなかった...", excellent: false },
  "elleb": { text: "右からやって来たね！", excellent: true }
};

/* PNG画像の下→上の順番 */
const symbols = ["e", "l", "l", "e", "b"];

/* 背景位置を中央揃えで更新する関数 */
function updateReelPosition(i) {
  reels[i].reelDiv.style.backgroundPositionY = -(positions[i] + centerOffset) + "px";
}

for (let i = 0; i < REELS; i++) {
  const reelDiv = document.createElement("div");
  reelDiv.className = "reel";
  updateReelPosition(i);

  const stopBtn = document.createElement("div");
  stopBtn.className = "stop-btn";
  stopBtn.textContent = "●";

  stopBtn.onclick = () => stopReel(i);
  stopBtn.ontouchstart = (e) => { e.preventDefault(); stopReel(i); };

  const wrapper = document.createElement("div");
  wrapper.style.textAlign = "center";
  wrapper.appendChild(reelDiv);
  wrapper.appendChild(stopBtn);

  reelsContainer.appendChild(wrapper);
  reels.push({ reelDiv, stopBtn });
}

function easeOutExpo(t) {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
}

function startGame() {
  for (let i = 0; i < REELS; i++) {
    spinning[i] = false;
    stopped[i] = true;
    speeds[i] = 0;

    const snap = Math.round(positions[i] / oneHeight) * oneHeight;
    positions[i] = snap % totalHeight;
    updateReelPosition(i);
  }

  startBtn.style.display = "none";
  excellent.style.display = "none";
  resultText.textContent = "";

  fixedMaxSpeed = baseMaxSpeed;

  speeds.fill(0);
  spinning.fill(true);
  stopped.fill(false);

  reels.forEach(r => r.stopBtn.style.display = "none");

  reels.forEach((_, i) => {
    setTimeout(() => accelerate(i), i * 100);
  });
}

startBtn.onclick = startGame;
startBtn.ontouchstart = (e) => { e.preventDefault(); startGame(); };

function accelerate(index) {
  const startTime = performance.now();

  function step(now) {
    if (!spinning[index]) return;

    const t = Math.min((now - startTime) / accelDuration, 1);
    speeds[index] = fixedMaxSpeed * easeOutExpo(t);

    positions[index] = (positions[index] - speeds[index] + totalHeight) % totalHeight;

    updateReelPosition(index);

    if (t < 1) {
      requestAnimationFrame(step);
    } else {
      speeds[index] = fixedMaxSpeed;
      if (index === 0) reels[index].stopBtn.style.display = "block";
      requestAnimationFrame(() => spinLoop(index));
    }
  }

  requestAnimationFrame(step);
}

function spinLoop(index) {
  if (!spinning[index] || stopped[index]) return;

  positions[index] = (positions[index] - speeds[index] + totalHeight) % totalHeight;

  updateReelPosition(index);

  requestAnimationFrame(() => spinLoop(index));
}

function stopReel(index) {
  if (stopped[index]) return;

  stopped[index] = true;
  spinning[index] = false;
  reels[index].stopBtn.style.display = "none";

  positions[index] = (positions[index] - speeds[index] * 1.2 + totalHeight) % totalHeight;

  const snapped = Math.round(positions[index] / oneHeight) * oneHeight;
  positions[index] = snapped % totalHeight;

  let shake = 15;
  function shakeAnim() {
    reels[index].reelDiv.style.backgroundPositionY =
      -(positions[index] + centerOffset + shake) + "px";
    shake *= -0.4;
    if (Math.abs(shake) > 1) {
      requestAnimationFrame(shakeAnim);
    } else {
      updateReelPosition(index);
      checkAllStopped();
    }
  }
  shakeAnim();

  if (index + 1 < REELS) {
    reels[index + 1].stopBtn.style.display = "block";
  }
}

function checkAllStopped() {
  if (!stopped.every(v => v)) return;

  const result = positions.map(p => symbols[Math.floor(p / oneHeight)]);
  const joined = result.join("");

  if (messages[joined]) {
    const msg = messages[joined];
    resultText.textContent = msg.text;
    excellent.style.display = msg.excellent ? "block" : "none";
  } else {
    resultText.textContent = "残念.....";
    excellent.style.display = "none";
  }

  startBtn.style.display = "inline-block";
}
</script>

</body>
</html>
